[{"content":"博客挂了两年，终于是在Github上复活了\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2024-07-07T00:00:00Z","image":"https://reatang.com/p/hello-world/cover_hu9852163441711757035.jpg","permalink":"https://reatang.com/p/hello-world/","title":"庆祝博客又又又一次复活了"},{"content":"在使用 net/http 库时，我们可能会遇到无法直接获取 HTTP 响应状态码的问题。为了优化这一点，我们可以采用以下两种方案：\n方案一：自定义 ResponseWriter 我们可以通过实现一个自定义的 ResponseWriter 来获取 HTTP 响应状态码。具体步骤如下：\n创建一个结构体，嵌入 http.ResponseWriter 并添加一个字段用于存储状态码。 实现 WriteHeader 方法，在调用原始 ResponseWriter 的 WriteHeader 方法之前，记录状态码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) type CustomResponseWriter struct { http.ResponseWriter StatusCode int } func (w *CustomResponseWriter) WriteHeader(code int) { w.StatusCode = code w.ResponseWriter.WriteHeader(code) } func handler(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusNotFound) fmt.Fprintf(w, \u0026#34;Hello, World!\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { crw := \u0026amp;CustomResponseWriter{ResponseWriter: w} handler(crw, r) fmt.Printf(\u0026#34;Response status code: %d\\n\u0026#34;, crw.StatusCode) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 方案二：使用 httpsnoop 包 httpsnoop 是一个第三方库，可以帮助我们更方便地获取 HTTP 响应状态码。使用方法如下：\n安装 httpsnoop 包：\n1 go get -u github.com/felixge/httpsnoop 使用 httpsnoop.CaptureMetrics 包装处理函数，从返回的 Metrics 中获取状态码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/felixge/httpsnoop\u0026#34; ) func handler(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusNotFound) fmt.Fprintf(w, \u0026#34;Hello, World!\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { metrics := httpsnoop.CaptureMetrics(handler, w, r) fmt.Printf(\u0026#34;Response status code: %d\\n\u0026#34;, metrics.Code) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 通过以上两种方案，我们可以有效地获取 HTTP 响应状态码，从而更好地处理和记录请求的应答信息。\n","date":"2024-10-30T15:49:43+08:00","permalink":"https://reatang.com/p/golang-http-code/","title":"[Golang] 在中间件中获取HTTP响应状态码的两种方法"},{"content":" 本文章通过两章讲解wireshark抓https包\n一、wireshark抓浏览器的https流量 参考文档\n1.1 设置 SSLKEYLOGFILE 环境变量让chrome将秘钥握手信息输出到文件 我安装的是zsh，配置文件是.zshrc\n1 2 3 \u0026gt; echo \u0026#39;export SSLKEYLOGFILE=~/.sslkeyfile.log\u0026#39; \u0026gt; .zshrc \u0026gt; touch ~/.sslkeyfile.log \u0026gt; chmod 600 ~/.sslkeyfile.log 1.2 设置 wireshark 打开配置界面：Edit -\u0026gt; Preferences。选择 Protocols \u0026gt; TLS\n通过浏览器发起请求则会成功解密（如果与网站已经成功握手，则不会产生sslkeylog）\n二、golang的http.Client也支持该种方案 参考文档\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) func getClient() (*http.Client, error) { // 读取环境配置 sslkeyfile := os.Getenv(\u0026#34;SSLKEYLOGFILE\u0026#34;) if sslkeyfile == \u0026#34;\u0026#34; { return nil, errors.New(\u0026#34;no SSLKEYLOGFILE environment variable\u0026#34;) } keyLogWriter, err := os.OpenFile(sslkeyfile, os.O_APPEND|os.O_RDWR, 0600) if err != nil { panic(err) } return \u0026amp;http.Client{ Transport: \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{ InsecureSkipVerify: true, // 本篇文章重点，设置Key日志 KeyLogWriter: keyLogWriter, }, }}, nil } func main() { client, _ := getClient() // 发送 GET 请求 resp, err := client.Get(\u0026#34;https://reatang.com\u0026#34;) if err != nil { fmt.Println(\u0026#34;Failed to send request:\u0026#34;, err) return } defer resp.Body.Close() // 打印响应状态码 fmt.Println(\u0026#34;Response status:\u0026#34;, resp.Status) } ","date":"2024-09-24T10:33:53+08:00","permalink":"https://reatang.com/p/golang-https-sslkeylogfile/","title":"[Golang] 让wireshark通过SSLKEYLOGFILE环境变量支持https抓包"},{"content":" SingleFlight: 单飞/单航。主要用于在并发场景下对多请求读取同一个数据进行控制，只允许其中一个请求真实发起读取，其他请求阻塞等待结果。\n缓存三大坑：\n穿透：因为错误的请求，缓存没有数据库也没有，导致一直触发DB操作。 应对： ① 为不存在的数据也构建空缓存。 ② 使用布隆过滤拦截不存在的数据。 击穿：缓存不存在或者过期的瞬间大量请求击穿缓存直接查询DB。 应对： ① 热点数据不设置过期时间，定期执行刷新（也要设计并发脏数据问题），或使用Canal之类的中间件做双写控制。 ② 使用并发控制，如SingleFlight。但是该工具也只应对单机并发，在数百个replicas下还需进一步优化。 雪崩：因为key的过期时间设置问题，导致大量缓存在短时间内失效。 应对： ① 设置宽范围的动态缓存时间 ② 上线预热数据 ③ 多级缓存架构 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package logic import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; \u0026#34;github.com/zeromicro/go-zero/core/logx\u0026#34; \u0026#34;github.com/zeromicro/go-zero/core/syncx\u0026#34; \u0026#34;reatang_demo_rpc/demo_rpc\u0026#34; \u0026#34;reatang_demo_rpc/internal/svc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/metadata\u0026#34; ) // 全局初始化一个SingleFlight组件 var redisCacheSingleFlight syncx.SingleFlight func init() { redisCacheSingleFlight = syncx.NewSingleFlight() } type RedisCacheLogic struct { ctx context.Context svcCtx *svc.ServiceContext logx.Logger } func NewRedisCacheLogic(ctx context.Context, svcCtx *svc.ServiceContext) *RedisCacheLogic { return \u0026amp;RedisCacheLogic{ ctx: ctx, svcCtx: svcCtx, Logger: logx.WithContext(ctx), } } // RedisCache 第一种：完全使用 SingleFlight 承压 func (l *RedisCacheLogic) RedisCache(in *demo_rpc.Request) (*demo_rpc.Response, error) { cacheKey := \u0026#34;cache:\u0026#34; + in.GetPing() // 直接使用 SingleFlight 减少 redis和db的压力 result, err := redisCacheSingleFlight.Do(cacheKey, func() (any, error) { var data string // 1、读取 cache data, err := l.svcCtx.CacheRedis.Get(l.ctx, cacheKey).Result() if err != nil \u0026amp;\u0026amp; !errors.Is(err, redis.Nil) { return \u0026#34;\u0026#34;, err } // 数据不存在或者过期 if errors.Is(err, redis.Nil) { // 2、查询数据库 data = strconv.Itoa(rand.Int()) // 模拟查询 // 3、缓存数据 l.svcCtx.CacheRedis.SetEX(l.ctx, cacheKey, data, time.Second*5) // （可选）标记读取了源数据 header := metadata.Pairs(\u0026#34;reload-cache\u0026#34;, \u0026#34;true\u0026#34;) _ = grpc.SendHeader(l.ctx, header) } // 4、返回数据 return data, nil }) if err != nil { return nil, err } else { return \u0026amp;demo_rpc.Response{ Pong: result.(string), }, nil } } // RedisCache2 第二种：redis承压，SingleFlight保护DB func (l *RedisCacheLogic) RedisCache2(in *demo_rpc.Request) (*demo_rpc.Response, error) { cacheKey := \u0026#34;cache2:\u0026#34; + in.GetKey() var data string // 读取 cache cacheResult, err := l.svcCtx.CacheRedis.Get(l.ctx, cacheKey).Result() if err != nil \u0026amp;\u0026amp; !errors.Is(err, redis.Nil) { return nil, err } if errors.Is(err, redis.Nil) { // 没有读取到缓存，执行单飞让并发请求中的一个请求去读取，其他请求等待 result, _ := redisCacheSingleFlight.Do(cacheKey, func() (any, error) { // 1、查询数据库 dbData := strconv.Itoa(rand.Int()) // 模拟查询 // 2、缓存数据 l.svcCtx.CacheRedis.SetEX(l.ctx, cacheKey, dbData, time.Second*5) // （可选）标记读取了源数据 header := metadata.Pairs(\u0026#34;reload-cache\u0026#34;, \u0026#34;true\u0026#34;) _ = grpc.SendHeader(l.ctx, header) // （可选）暂停10ms，防止有请求瞬间未读取到redis数据， // 也错过SingleFlight数据，导致SingleFlight又被唤醒 time.Sleep(10 * time.Millisecond) // 3、返回数据 return dbData, nil }) // 此处所有在等待的请求都会得到同样的数据 data = result.(string) } else { // 读取到了缓存 data = cacheResult } return \u0026amp;demo_rpc.Response{ Pong: data, }, nil } ","date":"2024-09-19T11:35:23+08:00","permalink":"https://reatang.com/p/golang-gozero-singleflight/","title":"[Golang]Gozero Singleflight 库使用"},{"content":"最近在开发中，组员报告了一个问题，读取配置文件的时候内嵌结构体（anonymous field）接收不到配置文件的参数。 经过排查，发现yaml编解码包的行为和json不太一样，这次就是这个差异导致的。\nyaml对内嵌结构体的赋值策略和json不同 上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gopkg.in/yaml.v3\u0026#34; ) type SubData struct { Sub1 string `yaml:\u0026#34;sub1\u0026#34;` } type Config struct { SubData Data1 string `yaml:\u0026#34;data1\u0026#34;` } func main() { y1 := ` data1: \u0026#34;aaaa\u0026#34; sub1: \u0026#34;bbbb\u0026#34; ` c := Config{} err := yaml.Unmarshal([]byte(y1), \u0026amp;c) if err != nil { panic(err) } fmt.Println(d) } 此处的预期输出应该为：{{bbbb} aaaa}，但是实际得到的确是：{{} aaaa}，内嵌结构体并没有收到的数据，这和json包的行为不一样。\n后来通过对yaml包的深入了解，原来yaml包需要添加：inline的tag属性，才可以达到效果。\n1 2 3 4 5 6 type Config struct { SubData `yaml:\u0026#34;,inline\u0026#34;` Data1 string `yaml:\u0026#34;data1\u0026#34;` } 得到正确的结果：{{bbbb} aaaa}\n另外，如果不加inline，那么yaml数据应该使用如下数据格式：\n1 2 3 data1: \u0026#34;aaaa\u0026#34; subdata: # 与结构体同名 sub1: \u0026#34;bbbb\u0026#34; ","date":"2024-08-21T14:40:48+08:00","permalink":"https://reatang.com/p/golang-yaml-inline/","title":"[Golang] yaml解析遇到内嵌结构体的问题"},{"content":"在观光一个go项目github.com/gotify/server的时候，它的两段代码引起了我的注意：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 文件: database/database.go if dialect == \u0026#34;sqlite3\u0026#34; { // We use the database connection inside the handlers from the http // framework, therefore concurrent access occurs. Sqlite cannot handle // concurrent writes, so we limit sqlite to one connection. // see https://github.com/mattn/go-sqlite3/issues/274 db.DB().SetMaxOpenConns(1) } if dialect == \u0026#34;mysql\u0026#34; { // Mysql has a setting called wait_timeout, which defines the duration // after which a connection may not be used anymore. // The default for this setting on mariadb is 10 minutes. // See https://github.com/docker-library/mariadb/issues/113 db.DB().SetConnMaxLifetime(9 * time.Minute) } 使用sqlite的时候，连接数只能设置为1.\n使用mysql的时候，连接最大时间为9分钟.\n记录一下\n","date":"2024-08-07T18:05:15+08:00","permalink":"https://reatang.com/p/golang-gorm-config/","title":"【golang】gorm的一些特殊的配置"},{"content":"默认的json使用的时间格式是 json.Time3339，这个时间的格式为：2006-01-02T15:04:05Z07:00\n而我们常用的格式：DateTime：2006-01-02 15:04:05 和 ISO8601：2006-01-02T15:04:05+0800\n一、DataTime 解析 库：github.com/reatang/go-json-datetime\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import( \u0026#34;fmt\u0026#34; \u0026#34;encoding/json\u0026#34; jsondt \u0026#34;github.com/reatang/go-json-datetime\u0026#34; ) type Data struct { CreateTime jsondt.DateTime `json:\u0026#34;create_time\u0026#34;` } func main() { j1 := `{\u0026#34;create_time\u0026#34;: \u0026#34;2024-07-10 18:52:19\u0026#34;}` var d Data err := json.Unmarshal(j1, \u0026amp;d) if err != nil { panic(err) } fmt.Println(d.CreateTime.Format(time.DateTime)) } 二、ISO8601 解析 有效的 ISO8601时间格式为：\n仅日期：\n2023-12-05 日期和时间（不含时区）：\n2023-12-05T14:30:00 日期和时间（含时区）：\n2023-12-05T14:30:00Z （Z 表示 UTC 时间） 2023-12-05T14:30:00+08:00 （+08:00 表示东八区时间） 仅时间（不含日期）：\n14:30:00 14:30:00.123 （包含毫秒） 周日期：\n2023-W50 （表示 2023 年的第 50 周） 2023-W50-2 （表示 2023 年第 50 周的第 2 天） 库：github.com/relvacode/iso8601\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/relvacode/iso8601\u0026#34; ) type Data struct { CreateTime iso8601.Time `json:\u0026#34;create_time\u0026#34;` } func main() { j1 := `{\u0026#34;create_time\u0026#34;:\u0026#34;2017-04-24T09:41:34+0800\u0026#34;}` var data Data err = json.Unmarshal([]byte(j1), \u0026amp;data) if err != nil { panic(err) } fmt.Println(data) } ","date":"2024-07-10T18:52:19+08:00","permalink":"https://reatang.com/p/golang-json-datetime/","title":"【Golang】让Json自动支持DateTime格式和ISO8601格式的时间"},{"content":"零、公共代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) var p1 = Person{ Name: \u0026#34;aaa\u0026#34;, Params: map[string]string{ \u0026#34;param1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;param2\u0026#34;: \u0026#34;value2\u0026#34;, }, Next: \u0026amp;Person{ Name: \u0026#34;bbb\u0026#34;, Params: map[string]string{ \u0026#34;param3\u0026#34;: \u0026#34;value3\u0026#34;, \u0026#34;param4\u0026#34;: \u0026#34;value4\u0026#34;, }, }, } type Person struct { Name string Params map[string]string Next *Person } 一、反射方案 使用库：github.com/mohae/deepcopy\n示例代码：\n1 2 3 4 5 6 import \u0026#34;github.com/mohae/deepcopy\u0026#34; func main() { p2 := deepcopy.Copy(p1).(types.Person) } 性能：\n1 BenchmarkDeepCopy-8 775651\t1503 ns/op 二、使用json 安装高性能的json库：github.com/json-iterator/go\n1 2 3 4 5 6 7 8 9 10 import jsoniter \u0026#34;github.com/json-iterator/go\u0026#34; var json = jsoniter.ConfigCompatibleWithStandardLibrary var p1j = json.Marshal(p1) func main() { var p2 types.Person err := json.Unmarshal(p1j, \u0026amp;p2) } 性能：\n1 2 # json-iterator 库性能 BenchmarkJsonIterJSON-8 1332277\t885.5 ns/op 1 2 # 标准库性能 BenchmarkStdJSON-8 541288\t2128 ns/op 三、k8s提供的deepcopy-gen 安装生成工具：\n1 go install k8s.io/code-generator/cmd/deepcopy-gen 添加doc.go文件：\n1 2 3 4 5 6 // file: doc.go // 此处是核心注解 // +k8s:deepcopy-gen=package package main 执行命令生成deepcopy代码：\n1 deepcopy-gen --output-file generated.deepcopy.go your_module_name/... 示例代码：\n1 2 3 func main() { p2 := p1.DeepCopy() } 性能\n1 BenchmarkK8sDepCopy-8 4201444\t294.9 ns/op ","date":"2024-07-10T18:00:05+08:00","permalink":"https://reatang.com/p/golang-deepcopy/","title":"【Golang】 变量深拷贝方案"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 syntax = \u0026#34;proto3\u0026#34;; // 版本 // 文档：https://developers.google.com/protocol-buffers/docs/proto3 package foo.bar; // 包 // 数据结构 message SearchRequest { // 数据类型 数据字段名称 = 数据编号。数据编号只能递增 string query = 1; int32 page_number = 2; int32 per_page = 3; } message SearchData { int32 id = 1; // string name = 2; 被删除 // int32 age = 3; 被删除 // 常量的内嵌写法 enum Sex { option allow_alias = true; // 将相同的值赋值给不同的常量，这个参数必须为true UNKNOWN = 0; MALE = 1; MAN = 1; FEMALE = 2; WOMAN = 2; } Sex sex = 4; // 注意，这里是序号，常量的默认值统一为0 // 字典类型 map\u0026lt;string, int\u0026gt; tags = 5; // 被删除的字段在兼容旧版本的情况下需标注保留 reserved 3; reserved \u0026#34;name\u0026#34;; } message SearchResponse { int32 ec = 1; string em = 2; // 内嵌数据结构 可用 SearchResponse.Page 引用 message Page { int32 page = 1; int32 per_page = 2; int32 total_page = 3; int32 count = 4; } Page page = 4; // repeated 表示数组 repeated SearchData data = 3; } // 总结：protobuf 与 json 数据类型对比 https://developers.google.com/protocol-buffers/docs/proto3#json // 定义具体的RPC服务 service SearchService { rpc Search (SearchRequest) returns (SearchResponse); } ","date":"2020-01-14T17:12:52Z","permalink":"https://reatang.com/p/old-post-44/","title":"【Prorobuf】一文学习protobuf语法"},{"content":"1、直接使用EVAL执行，不算在“更好”的范围内，不做讨论。\n2、正常判断式：先判断脚本存不存在，再进行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 向Redis注册Lua脚本 * * @param Redis $redis * @param $file * * @return bool|mixed|string */ function load_lua_script(Redis $redis, $file) { if (!is_file($file)) { return false; } $sha1 = sha1_file($file); if ($redis-\u0026gt;script(\u0026#39;EXISTS\u0026#39;, $sha1)[0] == 1) { return $sha1; } else { return $redis-\u0026gt;script(\u0026#39;LOAD\u0026#39;, file_get_contents($file)); } } $script_sha = load_lua_script($redis, \u0026#39;/path/to/lua_script.lua\u0026#39;); $reuslt = $redis-\u0026gt;evalSha($script_sha, $args, $key_number); 3、触发式执行：如果执行失败了，才LOAD脚本，并重新运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 执行Lua脚本 * * @param Redis $redis * @param $file * @param $args * @param $numKeys * * @return bool|mixed|string */ function run_lua_script(Redis $redis, $file, $args, $numKeys) { if (!is_file($file)) { return false; } $sha1 = sha1_file($file); for ($run_number = 0; $run_number \u0026lt; 3; $run_number++) { $redis_result = $redis-\u0026gt;evalSha($sha1, $args, $numKeys); // 检测脚本是否不存在，如果不存在，则加载，并重新执行 if (substr($redis-\u0026gt;getLastError(), 0, 8) === \u0026#39;NOSCRIPT\u0026#39;) { echo \u0026#39;LOAD\u0026#39; . PHP_EOL; $sha1 = $redis-\u0026gt;script(\u0026#39;LOAD\u0026#39;, file_get_contents($file)); $redis-\u0026gt;clearLastError(); continue; } return $redis_result; } return false; } $reuslt = run_lua_script($redis, \u0026#39;/path/to/lua_script.lua\u0026#39;, $args, $key_number); 测试：\nLua脚本：\n1 2 3 4 5 -- lua_script.lua local value = redis.call(\u0026#39;INCRBY\u0026#39;, KEYS[1], ARGV[1]) return \u0026#39;hello \u0026#39; .. value 二号脚本测试运行10000次：8万次单程 IO 运行 0.9738 秒。\n三号脚本测试运行10000次：4万次单程 IO 运行 0.6284 秒。\n显而易见，触发式脚本可以更好的节约IO、以高的性能运行。\n","date":"2019-11-20T19:19:05Z","permalink":"https://reatang.com/p/old-post-43/","title":"【PHP】Redis 中如何更好的加载Lua脚本"},{"content":"在很多项目中，有时候无法加入webpack等编译工具，要是想使用ElementUI就非常困难了。\n不过还好浏览器加载标准requirejs可以解决这个问题。\n1、关键点在于，requirejs的define函数已经定义的ElementUI组件的名称为 ELEMENT，所以引入的时候必须使用这个名称。\n2、使用requirejs的时候，ElementUI组件是不会自动注册到Vue中的，必须使用 ELEMENT.install(Vue); 手动注册。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;使用requirejs加载ElementUI\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;v-app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;value1\u0026#34; type=\u0026#34;datetimerange\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34; :default-time=\u0026#34;[\u0026#39;12:00:00\u0026#39;]\u0026#34; value-format=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; require.config({ map: { //map告诉RequireJS在任何模块之前，都先载入这个css模块 \u0026#39;*\u0026#39;: { css: \u0026#39;/js/require-css.js\u0026#39; } }, paths: { \u0026#39;vue\u0026#39;: \u0026#39;https://unpkg.com/vue/dist/vue\u0026#39;, \u0026#39;ELEMENT\u0026#39;: \u0026#39;/js/elementui/index\u0026#39; }, shim: { \u0026#39;ELEMENT\u0026#39;: { deps: [\u0026#39;vue\u0026#39;, \u0026#39;css!/js/elementui/theme-chalk/index.css\u0026#39;] } } }); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([\u0026#39;vue\u0026#39;, \u0026#39;ELEMENT\u0026#39;], function (Vue, ELEMENT) { ELEMENT.install(Vue); window.vm = new Vue({ el: \u0026#39;#v-app\u0026#39;, delimiters: [\u0026#39;${\u0026#39;, \u0026#39;}\u0026#39;], data: function () { return { value1: [] } }, }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2019-06-03T20:16:39Z","permalink":"https://reatang.com/p/old-post-41/","title":"【Vue】在requirejs中使用ElementUI"},{"content":"在Docker的PHP官方镜像中，存在着这样几个命令\n1 2 3 4 5 6 7 8 9 docker-php-entrypoint docker-php-ext-configure docker-php-ext-enable docker-php-ext-install docker-php-source 安装扩展主要用到了：docker-php-ext-install 命令。\n简单的安装一个pdo_mysql\n1 \u0026gt; docker-php-ext-install pdo_mysql 完事儿~\n更多细节请访问： Github\n","date":"2019-04-30T23:07:51Z","permalink":"https://reatang.com/p/old-post-40/","title":"【Docker】php官方镜像如何安装扩展"},{"content":"Laravel用习惯了以后，再用别的小框架总是想把Laravel的东西摘过去。。。这次摘一下视图层view\n目录结构\n1 2 3 4 5 6 7 ├── compiled │ └── .gitkeep ├── composer.json ├── composer.lock ├── start.php └── views └── welcome.blade.php 安装composer包：\n1 composer require illuminate/view 5.7.\\* 关键代码：\nstart.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 \u0026lt;?php /** * Created by PhpStorm. * User: reatang * Date: 2019/3/15 * Time: 下午6:26 * Author reatang */ include __DIR__ . \u0026#39;/vendor/autoload.php\u0026#39;; // 视图系统 use \\Illuminate\\View\\Engines\\EngineResolver; use \\Illuminate\\View\\Engines\\FileEngine; use \\Illuminate\\View\\Engines\\PhpEngine; use \\Illuminate\\View\\Compilers\\BladeCompiler; use \\Illuminate\\View\\Engines\\CompilerEngine; use \\Illuminate\\View\\FileViewFinder; use \\Illuminate\\View\\Factory; use \\Illuminate\\View\\View; //文件系统 use \\Illuminate\\Filesystem\\Filesystem; //事件系统 use \\Illuminate\\Events\\Dispatcher; /** * 配置 */ // 模板文件目录 $config[\u0026#39;view.paths\u0026#39;] = [__DIR__ . \u0026#39;/views/\u0026#39;]; // 编译模板缓存目录 $config[\u0026#39;view.compiled\u0026#39;] = __DIR__ . \u0026#39;/compiled/\u0026#39;; /** * 文件系统抽象 */ $GLOBALS[\u0026#39;__files\u0026#39;] = new Filesystem(); /** * 事件管理器 */ $GLOBALS[\u0026#39;__events\u0026#39;] = new Dispatcher(); /** * 模板编译器 */ $resolver = new EngineResolver(); $resolver-\u0026gt;register(\u0026#39;file\u0026#39;, function () { return new FileEngine(); }); $resolver-\u0026gt;register(\u0026#39;php\u0026#39;, function () { return new PhpEngine(); }); $resolver-\u0026gt;register(\u0026#39;blade\u0026#39;, function () use ($config) { $blade_compiler = new BladeCompiler( $GLOBALS[\u0026#39;__files\u0026#39;], $config[\u0026#39;view.compiled\u0026#39;] ); return new CompilerEngine($blade_compiler); }); /** * 模板文件管理器 */ $finder = new FileViewFinder($GLOBALS[\u0026#39;__files\u0026#39;], $config[\u0026#39;view.paths\u0026#39;]); /** * 视图工厂 */ $factory = new Factory($resolver, $finder, $GLOBALS[\u0026#39;__events\u0026#39;]); /** * 命令 */ /** * 清除视图缓存 */ function view_clear() { /** * @var array $config * @var Filesystem $__files */ global $config, $__files; $path = $config[\u0026#39;view.compiled\u0026#39;]; if (! $path) { throw new RuntimeException(\u0026#39;View path not found.\u0026#39;); } foreach ($__files-\u0026gt;glob(\u0026#34;{$path}/*\u0026#34;) as $view) { if (strpos($view, \u0026#39;gitkeep\u0026#39;) === false) { $__files-\u0026gt;delete($view); } } echo \u0026#39;Compiled views cleared!\u0026#39; . PHP_EOL; } /** * 初始化完成 * * 弱化： * 1、无容器，所以无法使用 class型的事件，只能用匿名函数 * 2、无多语言，未加载多语言组件（因为也需要容器），无法使用 @lang @trans * 3、没有auth系统，所以无法用 @auth @guest 之类的认证功能 * 4、没有session功能，所有无法使用 @csrf 功能 * 5、没有容器，无法使用 @inject 功能 * 6、没有LaravelCore不能使用 @method * 7、还有未知的弱化内容未发现.... */ // 扩展 Blade /** @var BladeCompiler $_compiler */ $_compiler = $resolver-\u0026gt;resolve(\u0026#39;blade\u0026#39;)-\u0026gt;getCompiler(); $_compiler-\u0026gt;directive(\u0026#39;lalala\u0026#39;, function ($expression) { return \u0026#34;\u0026lt;?php echo ($expression)-\u0026gt;format(\u0026#39;m/d/Y H:i\u0026#39;); ?\u0026gt;\u0026#34;; }); // 模板事件可注入参数 模板文件支持通配符 $factory-\u0026gt;creator(\u0026#39;welcome\u0026#39;, function (View $view) { // creator 是在视图被make的时候立马触发 $view-\u0026gt;with(\u0026#39;creator_var\u0026#39;, \u0026#39;creator 注入\u0026#39;); }); $factory-\u0026gt;composer(\u0026#39;welcome\u0026#39;, function (View $view) { // composer 是在视图render时触发 $view-\u0026gt;with(\u0026#39;composer_var\u0026#39;, \u0026#39;composer 注入\u0026#39;); }); //共享变量特性 $factory-\u0026gt;share(\u0026#39;global_var1\u0026#39;, \u0026#39;全局共享变量\u0026#39;); //渲染 echo $factory-\u0026gt;make(\u0026#39;welcome\u0026#39;)-\u0026gt;render(); welcome.blade.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?php $hello = \u0026#39;你好\u0026#39; ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;你好 Blade\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; {{ $hello }} \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; @foreach ([1,2,3] as $v) \u0026lt;li\u0026gt;{{ $v }}\u0026lt;/li\u0026gt; @endforeach \u0026lt;/ul\u0026gt; \u0026lt;div\u0026gt; {{ $global_var1 }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{ $creator_var }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{ $composer_var }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; @lalala(\\Carbon\\Carbon::now()) \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2019-03-16T21:15:19Z","permalink":"https://reatang.com/p/old-post-39/","title":"【Laravel】单独使用illuminate/view作为模板引擎"},{"content":"在自己的plugin添加过滤器钩子：\n1 2 3 4 5 6 7 8 9 10 //添加分页按钮 add_filter(\u0026#39;mce_buttons\u0026#39;, function ($btn_lists, $editor_id) { if (($wp_more_btn_index = array_search(\u0026#39;wp_more\u0026#39;, $btn_lists)) \u0026gt;= 0) { array_splice($btn_lists, $wp_more_btn_index + 1, 0, \u0026#39;wp_page\u0026#39;); } return $btn_lists; }, 10, 2); ","date":"2018-07-09T14:32:52Z","permalink":"https://reatang.com/p/old-post-37/","title":"【wordpress】文章编辑器中添加分页按钮"},{"content":"最近在为公司设计认证系统，使用laravel当然自动想到使用 laravel/passport 这个包来实现。\n不过有一个小问题，就是所有类型的token都只统一使用：\n1 Passport::tokensExpireIn(now()-\u0026gt;addSeconds(3600)); 这种方式来定义有效期。不过对于机器对机器的Client Token 而言，3600s实在是有些短，通过一下午各种hack不得法\u0026hellip;发现了服务提供器已经率先注入了时间，所以直接继承passport包的 PassportServiceProvider 并修改 registerAuthorizationServer 的内容，即可单独设定有效期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class PassportServiceProvider extends PassportPassportServiceProvider { /** * 单独 调整了 client token 的 时间 * * @return void */ protected function registerAuthorizationServer() { $this-\u0026gt;app-\u0026gt;singleton(AuthorizationServer::class, function () { return tap($this-\u0026gt;makeAuthorizationServer(), function ($server) { $server-\u0026gt;enableGrantType( $this-\u0026gt;makeAuthCodeGrant(), Passport::tokensExpireIn() ); $server-\u0026gt;enableGrantType( $this-\u0026gt;makeRefreshTokenGrant(), Passport::tokensExpireIn() ); $server-\u0026gt;enableGrantType( $this-\u0026gt;makePasswordGrant(), Passport::tokensExpireIn() ); $server-\u0026gt;enableGrantType( new PersonalAccessGrant, new \\DateInterval(\u0026#39;P1Y\u0026#39;) ); $server-\u0026gt;enableGrantType( new ClientCredentialsGrant, new \\DateInterval(\u0026#39;P1D\u0026#39;)//手动设定时间 Passport::tokensExpireIn() ); if (Passport::$implicitGrantEnabled) { $server-\u0026gt;enableGrantType( $this-\u0026gt;makeImplicitGrant(), Passport::tokensExpireIn() ); } }); }); } } 别忘记了在 config/app.php 中重新设定 provider。\n","date":"2018-04-28T17:49:07Z","permalink":"https://reatang.com/p/old-post-36/","title":"【Laravel】记 laravel/passport 单独调整每种token的有效期的 Hack操作"},{"content":"一个通用的倒计时函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 ;(function(root, factory) { if (typeof module === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; module \u0026amp;\u0026amp; module.exports) { module.exports = factory(); } else if (typeof define === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; define.amd) { define([], factory); } else { root.countdown = factory(); } }(this, function() { function countdown(seconds, onTicktock, onOver) { if (seconds \u0026lt;= 0) { console.error(\u0026#39;[countdown Error] #1 argument must be greater than 0\u0026#39;); return null; } if (typeof onTicktock != \u0026#39;function\u0026#39;) { console.error(\u0026#39;[countdown Error] #2 argument must be a function\u0026#39;); return null; } //倒计时剩余时间 var restof = seconds; //计时器 var timer = null; //计时器间隔 var intervalTime = 1000; function ticktock () { if (restof \u0026gt; -1) { // 0 也会返回 onTicktock(restof--, stop); } else { stop(); } } function stop () { clearInterval(timer); timer = null; onOver \u0026amp;\u0026amp; typeof onOver == \u0026#39;function\u0026#39; \u0026amp;\u0026amp; onOver(); } //先执行一次 ticktock(); timer = setInterval(function () { ticktock(); }, intervalTime); return stop; } return countdown; })); 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function t (sec, stop) { console.log(\u0026#39;剩余：\u0026#39; + sec + \u0026#39;秒\u0026#39;); } function s () { console.log(\u0026#39;倒计时结束\u0026#39;); } var callStop = countdown(5, t, s); //console VM366:2 剩余：5秒 VM366:2 剩余：4秒 VM366:2 剩余：3秒 VM366:2 剩余：2秒 VM366:2 剩余：1秒 VM366:2 剩余：0秒 VM366:6 倒计时结束 ","date":"2018-04-09T13:18:03Z","permalink":"https://reatang.com/p/old-post-35/","title":"【前端】一个简单的倒计时函数"},{"content":"xhorof php性能分析工具 原创文章，转载请注明出处： {#ZC_BLOG_HOST#}?id=34\n工具：\nphp \u0026gt;= 7.0: https://github.com/longxinH/xhprof\nphp \u0026lt; 7.0 : https://github.com/phacility/xhprof\n1、创建文件 php71-xhprof.rb\n1 $\u0026gt;touch /usr/local/Homebrew/Library/Taps/homebrew/homebrew-php/Formula/php71-xhprof.rb 2、选择你喜欢的编辑器打开上面创建的文件，然后将如下内容复制进去并保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # file /usr/local/Homebrew/Library/Taps/homebrew/homebrew-php/Formula/php71-xhprof.rb require File.expand_path(\u0026#34;../../Abstract/abstract-php-extension\u0026#34;, __FILE__) class Php71Xhprof \u0026lt; AbstractPhp71Extension init desc \u0026#34;XHProf is a function-level hierarchical profiler for PHP and has a simple HTML based user interface.\u0026#34; homepage \u0026#34;https://github.com/longxinH/xhprof\u0026#34; url \u0026#34;https://github.com/longxinH/xhprof/archive/v1.2.tar.gz\u0026#34; sha256 \u0026#34;a0026e6047512ee289e59b188a40a6517aace40d4c65f7f23714aa4f0458089c\u0026#34; head \u0026#34;https://github.com/longxinH/xhprof.git\u0026#34; depends_on \u0026#34;pcre\u0026#34; def install Dir.chdir \u0026#34;extension\u0026#34; do ENV.universal_binary if build.universal? safe_phpize system \u0026#34;./configure\u0026#34;, \u0026#34;--prefix=#{prefix}\u0026#34;, phpconfig system \u0026#34;make\u0026#34; prefix.install \u0026#34;modules/xhprof.so\u0026#34; end prefix.install %w[xhprof_html xhprof_lib] write_config_file if build.with? \u0026#34;config-file\u0026#34; end end 3、使用命令开始安装\n1 $\u0026gt;brew install homebrew/php/php71-xhprof 4、编辑配置文件\n1 2 3 4 5 6 7 ; file /usr/local/etc/php/7.1/conf.d/ext-xhprof.ini [xhprof] extension=\u0026#34;/usr/local/opt/php71-xhprof/xhprof.so\u0026#34; ; 我的配置是设置为我的家目录 xhprof.output_dir=\u0026#34;/Users/reatang/.xhprof\u0026#34; 5、将xhprof的web页面添加到nginx配置中（如：创建xhprof.conf），并重启nginx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # file /usr/local/etc/nginx/servers/xhprof.conf server { listen 80; server_name xhprof.local; # 需要填入 /etc/hosts index index.php index.html index.htm; charset utf-8; root \u0026#34;/usr/local/Cellar/php71-xhprof/1.2/xhprof_html/\u0026#34;; location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } location ~ /\\.ht { deny all; } location / { try_files $uri $uri/ /index.php?$query_string; } location ~ \\.php { fastcgi_pass 127.0.0.1:9000; # 如果用的是Laravel的 valet，则写：unix:/Users/reatang/.valet/valet.sock try_files $uri /index.php = 404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } 6、重启 nginx，重启php-fpm\n7、可以看一看 https://github.com/longxinH/xhprof 的示例代码进行使用操作\n注意： 可能需要安装图片工具：\n1 $\u0026gt;brew install graphviz p.s：做了一个laravel5.5的测试，无法直视\n确实是一个hello world 12000+的调用\n","date":"2018-03-19T12:48:20Z","permalink":"https://reatang.com/p/old-post-34/","title":"【brew】创建一个php71的xhprof安装包"},{"content":"使用trait的功能使类变为单例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?php trait SingletonObject { protected static $_singleton = null; final private function __clone() {} final private function __sleep() {} final private function __wakeup() {} protected function __construct() {} /** * 返回单例 * * @return mixed */ final public static function getInstance() { if (is_null(static::$_singleton)) { static::$_singleton = static::singleton(); } return static::$_singleton; } /** * 这个方法只会被调用一次，用于生产单例的时候 * 如果类有特殊的参数，则需要重写这个方法 * * @return mixed */ protected static function singleton() { return new static(); } } 使用：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php class NeedSingleton { use SingletonObject; } //则直接可以使用 $s = NeedSingleton::getInstance(); 如果构造类的时候需要初始化参数，则可以重写`singleton`方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class NeedSingleton2 { use SingletonObject; protected $config = []; protected function __construct($config) { $this-\u0026gt;config = $config; } protected static function singleton() { $config = [ // some config ]; return new static($config); } } //或者直接重写 __construct 就好了 class NeedSingleton3 { use SingletonObject; protected $config = []; protected function __construct() { $config = [ // some config ]; $this-\u0026gt;config = $config; } } ","date":"2017-11-13T17:43:00Z","permalink":"https://reatang.com/p/old-post-33/","title":"【PHP】一个方便实现单例的功能"},{"content":"1、把图片放入 C:\\Windows\\System32\\oobe\\info\\backgrounds\n2、改名为：BackgroundDefault.jpg\n3、创建文件：win_login_background.reg 粘贴下面内容到文件内，并执行\n1 2 3 4 Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI\\Background] \u0026#34;OEMBackground\u0026#34;=dword:00000001 ","date":"2017-10-28T14:51:35Z","permalink":"https://reatang.com/p/old-post-32/","title":"Window7修改登陆页面图片"},{"content":" 前言： 在大型富交互的项目中，前后端分离的设计越来越受到重视。\n为了方便前后端同学在一个项目中进行开发，我这边的项目搭建并没有使用laravel-mix（领导说不要使用不熟悉的东西），而是直接使用vue+webpack进行搭建。\n背景： - resources\n- views 模板文件\n- index 入口文件放置的文件夹\n- vue vue全部文件，blade的模板文件\n- build 构建参数和脚本\n- src 源代码\n- tpl 需要构建给laravel blade的模板文件\n- config 构建环境参数\n- public\n- v webpack的构建内容全部在放在这里，当然这个是要配置的\n坑们： 主要的坑都来自开发环境\n坑一：页面入口问题。 在vue默认的项目中，代码会自动生成一个index.html作为首页。而在laravel中使用的blade模板。我首先想了两个方案。\n1、使用插件 assets-webpack-plugin 生成assets.json 文件，然后由php动态解析到模板中。\n2、直接由webpack构建系统生成blade模板\n坑一解决：\n第一种做法操作简单，不过每次都要解析assets.json文件。\n第二种做法不需要解析文件，但是需要让vue的构建系统侵入(或叫操作) laravel的文件夹（views中添加文件）。\n不过这两种方法在dev模式下都有一个问题，热更新模式下都不会生成文件。不管是assets.json 还是 index.blade.php（坑二解决）。\n坑二：热更新的情况话不会生成index.blade.php文件。 坑二解决：我在 build/dev-server.js 中添加了强制复制 resouces/vue/tpl/index_dev.blade.php 到 resouces/views/index/index.blade.php。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //build/dev-server.js 文件 ... var opn = require(\u0026#39;opn\u0026#39;) var path = require(\u0026#39;path\u0026#39;) var express = require(\u0026#39;express\u0026#39;) var webpack = require(\u0026#39;webpack\u0026#39;) var proxyMiddleware = require(\u0026#39;http-proxy-middleware\u0026#39;) var webpackConfig = require(\u0026#39;./webpack.dev.conf\u0026#39;) // copy函数会把模板文件复制到views中供laravel解析 var fs = require(\u0026#39;fs\u0026#39;); function copy(src, dst) { fs.createReadStream(src).pipe(fs.createWriteStream(dst)); } // 测试的时候应该把测试用的index文件复制到真正的文件中 copy(__dirname + \u0026#39;/../tpl/index_dev.blade.php\u0026#39;, __dirname + \u0026#39;/../../views/index/index.blade.php\u0026#39;); //本文附录中会带index_dev.blade.php文件内容 ... 当然，在npm run build 的时候也得构建正常的index.blade.php文件到views中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // build/webpack.prod.conf.js 文件 ... new HtmlWebpackPlugin({ filename: resolve(\u0026#39;../../views/index/index.blade.php\u0026#39;), template: resolve(\u0026#39;./tpl/index_tpl.blade.php\u0026#39;), //webpack 会自动将脚本注入body尾部，为了方便语法，模板文件的文件后缀也用了blade.php //本文附录中会带index_tpl.blade.php文件内容 inject: true, minify: { removeComments: true, collapseWhitespace: false, //注意不要设置为true ，会将模板内格式删除，不利于blade解析 removeAttributeQuotes: true }, chunksSortMode: \u0026#39;dependency\u0026#39; }), ... 坑三：热更新的地址指向问题。 因为laravel开发都是使用nginx或者valet 所以laravel使用的是127.0.0.1:80端口或者 project_dir.dev 域名，而热更新使用肯定是127.0.0.1:8080作为端口（端口可设置）所以造成了热资源无法读取\n坑三解决：\nbuild/dev-client.js 设定绝对路径\n1 2 3 4 5 6 // build/dev-client.js var hotClient = require(\u0026#39;webpack-hot-middleware/client?noInfo=false\u0026amp;reload=true\u0026#39;) // 改为 var hotClient = require(\u0026#39;webpack-hot-middleware/client?path=http://127.0.0.1:8080/__webpack_hmr\u0026amp;noInfo=false\u0026amp;reload=true\u0026#39;) 热更新会自动使用 / 作为根地址，所以要将webpack的 publicPath地址设置为绝对路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // webpack.base.conf.js 原 ... publicPath: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? config.build.assetsPublicPath : config.dev.assetsPublicPath ... // 改为 ... publicPath: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? config.build.assetsPublicPath : \u0026#39;http://127.0.0.1:8080/\u0026#39; // 这里也可修改 config.dev.assetsPublicPath 对应的内容 ... 坑四：热更新跨域问题。 坑四解决：\n在build/dev-server.js中设置跨域头\n1 2 3 4 5 6 7 8 9 10 11 // build/dev-server.js // 在生成app变量后 // 设置全局跨域 app.all(\u0026#39;*\u0026#39;, function(req, res, next) { res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); res.header(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;PUT, GET, POST, DELETE, OPTIONS\u0026#39;); res.header(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;X-Requested-With\u0026#34;); res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-Type\u0026#39;); next(); }); 总结： 写了这么多，发现全都是热更新的问题= =，不过搞定以上几点，对于laravel + vue 的前后端分离开发就很方便了，前端依然用自己的方式去开发，后端只提供一个入口index，剩下的都走API。\n附录： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // index_dev.blade.php \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;main-app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- built files will be auto injected --\u0026gt; \u0026lt;script src=\u0026#34;http://127.0.0.1:8080/vendor.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://127.0.0.1:8080/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 有新的内容请手动填写 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // index_tpl.blade.php \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;main-app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- built files will be auto injected --\u0026gt; \u0026lt;!-- 新内容将自动注入 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2017-08-18T14:12:14Z","permalink":"https://reatang.com/p/old-post-31/","title":"【爬坑】在laravel中使用vue（非laravel-mix）"},{"content":"THE BATTERY OPEN-SOURCE SOFTWARE INDEX排名项目名综合项目评分领域****相关公司1Linux100.00IT OperationsRed Hat, Ubuntu2Git31.10DevOpsGitHub, GitLab3MySQL25.23Data \u0026amp; AnalyticsOracle4Node.js22.75DevOpsNodeSource, Rising Stack5Docker22.61DevOpsDocker6Hadoop16.19Data \u0026amp; AnalyticsCloudera, Hortonworks7Elasticsearch15.72Data \u0026amp; AnalyticsElastic8Spark14.99Data \u0026amp; AnalyticsDatabricks9MongoDB14.68Data \u0026amp; AnalyticsMongoDB10Selenium12.81DevOpsSauce Labs, BrowserStack11NPM12.31DevOpsNPM12Redis11.61Data \u0026amp; AnalyticsRedis Labs13Tomcat11.04IT OperationsNA14Jenkins10.47DevOpsCloudBees15Vagrant8.15IT OperationsHashiCorp16Postgres8.02Data \u0026amp; AnalyticsEnterpriseDB17Gradle7.68DevOpsGradle18Nginx7.57IT OperationsNginx19Ansible7.42IT OperationsAnsible20Kafka7.22Data \u0026amp; AnalyticsConfluent21GitLab6.42DevOpsGitLab22Hbase6.41Data \u0026amp; AnalyticsCloudera, Hortonworks23Chef6.37IT OperationsChef*24TensorFlow5.97Data \u0026amp; AnalyticsGoogle25Cassandra5.74Data \u0026amp; AnalyticsDataStax\n转自：https://linux.cn/article-8759-1.html\n","date":"2017-08-16T00:45:00Z","permalink":"https://reatang.com/p/old-post-30/","title":"【转】硅谷风投最青睐的 25 个开源项目"},{"content":"Laravel的SQL日志是一个数组类型的内容\n格式大概是:\n1 2 3 4 5 6 7 8 $sqlLogPayload = [ \u0026#39;query\u0026#39; =\u0026gt; \u0026#39;sql语句\u0026#39;, \u0026#39;bindings\u0026#39;=\u0026gt; [ \u0026#39;参数A\u0026#39;, \u0026#39;参数B\u0026#39; ], \u0026#39;time\u0026#39; =\u0026gt; \u0026#39;0.23\u0026#39; ]; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * SQL 日志转换为字符串 * * @param string $sql SQL预处理 * @param string $bindings 绑定的参数 * @param string $time 执行时间 * @return string 返回一个解析完成的sql （带时间） */ function laravel_sql_parse($sql, $bindings, $time = null) { $bindings = array_map(function($bind){ if ($bind instanceof \\DateTime) { $bind = $bind-\u0026gt;format(\u0026#39;Y-m-d H:i:s\u0026#39;); } return is_numeric($bind) ? $bind : \u0026#34;\u0026#39;{$bind}\u0026#39;\u0026#34;; }, $bindings); array_unshift($bindings, str_replace([\u0026#39;%\u0026#39;, \u0026#39;?\u0026#39;], [\u0026#39;%%\u0026#39;, \u0026#39;%s\u0026#39;], $sql)); $sql_str = count($bindings) == 1 ? current($bindings) : call_user_func_array(\u0026#34;sprintf\u0026#34;, $bindings); return $sql_str . ( is_null($time) ? \u0026#34;\u0026#34; : \u0026#34; [{$time}ms]\u0026#34;); } ","date":"2017-05-25T18:10:54Z","permalink":"https://reatang.com/p/old-post-29/","title":"【常用函数】Laravel SQL 日志转换为字符串 函数"},{"content":"小米是经常用到的PHP扩展库\nbcmath\nbz2\ncalendar\nCore\nctype\ncurl\ndate\ndba\ndom\nereg\nexif\nfileinfo\nfilter\nftp\ngd\ngettext\nhash\niconv\nigbinary\njson\nldap\nlibxml\nmbstring\nmcrypt\nmhash\nmysql\nmysqli\nmysqlnd\nodbc\nopenssl\npcntl\npcre\nPDO\npdo_mysql\nPDO_ODBC\npdo_sqlite\nPhar\nposix\nprotobuf\nreadline\nredis\nReflection\nsession\nshmop\nSimpleXML\nsoap\nsockets\nSPL\nsqlite3\nstandard\nswoole\nsysvmsg\nsysvsem\nsysvshm\ntokenizer\nwddx\nxml\nxmlreader\nxmlrpc\nxmlwriter\nxsl\nyaf\nyar\nZend OPcache\nzip\nzlib\nzmq\n","date":"2017-05-15T11:40:03Z","permalink":"https://reatang.com/p/old-post-28/","title":"PHP扩展一览"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function view($__path, $__data) { $obLevel = ob_get_level(); ob_start(); extract($__data); try { include $__path; } catch (Exception $e) { while (ob_get_level() \u0026gt; $obLevel) { ob_end_clean(); } throw $e; } return ltrim(ob_get_clean()); } ","date":"2017-05-10T10:54:36Z","permalink":"https://reatang.com/p/old-post-27/","title":"【常用函数】最简单的模板引擎，摘自Laravel"},{"content":"准备新做一个组件库，主打应用层流行的通讯协议、web即时通信、异构系统互联方面的功能\nEventSource GitHub\n","date":"2017-04-01T19:29:56Z","permalink":"https://reatang.com/p/old-post-26/","title":"firefly-php(萤火虫PHP)"},{"content":"（零）没有并发控制 存在的问题：更新遗失。\n解决办法就是下面的“可读取未确认”。\n（一）可读取未确认（Read uncommitted） 写事务阻止其他写事务，避免了 更新遗失。但是没有阻止其他读事务。\n存在的问题：脏读。即读取到不正确的数据，因为另一个事务可能还没提交最终数据，这个读事务就读取了中途的数据，这个数据可能是不正确的。\n解决办法就是下面的“可读取确认”。\n（二）可读取确认（Read committed） 写事务会阻止其他读写事务。读事务不会阻止其他任何事务。\n存在的问题：不可重复读。即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务。\n解决办法就是下面的“可重复读”。\n（三）可重复读（Repeatable read） 读事务会阻止其他写事务，但是不会阻止其他读事务。\n存在的问题：幻读。可重复读阻止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。\n解决办法就是下面的“串行化”。\n（四）可串行化（Serializable） 读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫串行化。\n隔离级别与并发性能的关系：\n设置隔离级别的原则：\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。\n对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读、虚读。\n和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。\n","date":"2017-03-30T14:47:14Z","permalink":"https://reatang.com/p/old-post-25/","title":"数据库的四个隔离级别"},{"content":"粒度是在一个体系（系统）中的最小单位的衡量。\n在编程开发中粒度从小到大可以扩展为：\n一个表达式 -\u0026gt; 一行代码 -\u0026gt; 一个函数 -\u0026gt; 一个模块 -\u0026gt; 一个组件 -\u0026gt; 一个系统 -\u0026gt; 一个分布式系统 -\u0026gt; 一个平台 -\u0026gt; 一个云\n在编程思想中粒度可以扩展为：\n过程 -\u0026gt; 结构/函数FP -\u0026gt; 面向对象OOP -\u0026gt; 面向服务SOA -\u0026gt; 面向切面AOP -\u0026gt; 面向领域DDD\n","date":"2017-03-30T14:22:29Z","permalink":"https://reatang.com/p/old-post-24/","title":"软件工程中的粒度"},{"content":"今天又仔仔细细的研究了一下鸟哥写的yield的文章： 传送门\n突然对yield的作用明晰了。\n就像很多人说的 yield 其实就是实现一种以同步方式写异步代码的功能，写了这么多年PHP，完全不清楚这个到底是啥意思。不过看完这篇文章算是懂了。\n一般的PHP代码（类似于同步IO）：\nPHP完全以同步的方式在处理 从 【PHP处理】 -\u0026gt; 【处理完成】的这个过程。因为毕竟一次处理一个请求。\n如果使用yield就完全不一样了（首先我们就不能用php-fpm了），php需要自己控制处理所有socket才能达到真异步。\n例，一个业务逻辑(普通的)：\n1 2 3 4 5 6 7 8 9 10 $data = DB::select(); $respA = $httpClient-\u0026gt;post($uri, $data); if ($respA[\u0026#39;code\u0026#39;] == 0) { $id = DB::insert($respA[\u0026#39;data\u0026#39;]); $respB = $httpClient-\u0026gt;post($uri, [\u0026#39;some_id\u0026#39; =\u0026gt; $id]); } return response()-\u0026gt;ok(); 如果我们用yield：\n1 2 3 4 5 6 7 8 9 10 $data = yield AsyncDB::select(); $respA = yield $AsyncHttpClient-\u0026gt;post($uri, $data); if ($respA[\u0026#39;code\u0026#39;] == 0) { $id = yield AsyncDB::insert($respA[\u0026#39;data\u0026#39;]); $respB = yield $AsyncHttpClient-\u0026gt;post($uri, [\u0026#39;some_id\u0026#39; =\u0026gt; $id]); } return response()-\u0026gt;ok(); 之前我一直很困惑，这么写有什么用呢？看了很多文章，甚至写了很多例子，都发现IO依然是同步的。\n这是因为，我们想用到真正的yield的功能就要整个环境（框架）都支持它。\nOK，详细来描述一下这段业务逻辑背后的事情：\n上图只是说一次请求。\nIO任务调度器是全局的，我们有成千上万个这种请求在处理：\nIO任务调度器的设计就像是epoll 或者 select 一样，非阻塞（同步或者异步）。只要有IO完成了，协程就会返回到这个IO当时yield的地方，继续执行（就像设置断点一样）。\n最后总结：\n在有协程的框架设计中任务调度器的设计就是提高程序性能的关键，假如普通的同步请求一个单位时间处理1一个请求，那么这种yeild协程就是看机器的性能了。\n","date":"2017-03-30T11:30:42Z","permalink":"https://reatang.com/p/old-post-23/","title":"我是这么理解协程yield异步IO的"},{"content":"对函数内部进行参数设置是在编码中经常遇见的一个设计问题，一般情况下，我们会有三种方式。\n1、2B程序员（没错这就是我经常用的那种） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function a_func($option1, $option2) { if ($option1) { //some code } else { //some code } if ($option2) { //some code } else { //some code } } 2、普通程序员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function b_func($options) { if ($options[\u0026#39;a\u0026#39;]) { //some code } else { //some code } if ($options[\u0026#39;b\u0026#39;]) { //some code } else { //some code } } 3、文艺的程序员 没错，今儿我就是要讲讲怎么个文艺法.\n3.1、对比一下 作为php程序员json_encode 这个函数肯定是再了解不过了，可是大家了解这个函数的第二个参数吗？\n1 2 //像这样 $data_str = json_encode($a, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); 从 json_encode() 的文档中，我们能得知第二参数的各个选项会对输出来的json字符串有不同的解析方式。\n对比一下1和2的用法：\n1 2 a_func(true, false) // 如果不知道函数原型的话根本不知道在干什么。 b_func([\u0026#39;a\u0026#39; =\u0026gt; true, \u0026#39;b\u0026#39; =\u0026gt; false]) // 如果是第三方用的话不一定知道还有a和b两个参数，还得去源码中找。 3.2、我们如何文艺的设计这样的函数 以我用laravel这么多年的经验来看，内部设计的越精巧复杂，外部用起来就越简单明了。没错，用这种文艺的方法，也会有点复杂。\n首先，设计一个解析函数：\n1 2 3 4 5 6 7 8 9 10 11 12 /** * 解析按位输入的参数 * * @param int $options 用户选择的参数 * @param int $all_options 所有参数 * @param int $default 默认值 * @return int 解析后的内容 */ function __parse_bitwise_params($options, $all_options, $default = 0) { return $all_options \u0026amp; $options ?: $default; } 看看使用场景：\n假如一个用户模块，我们想获取用户的信息，那么其实我们可以这样写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 用户模块 */ class UserModule { const USER_RAW = 1; const USER_STR = 2; const USER_ARRAY = 4; /** * @var User */ protected $user; public function getInfo($options = self::INFO_RAW) { $type = __parse_bitwise_params($options, self::USER_RAW | self::USER_STR | self::USER_ARRAY); switch($type){ case self::USER_RAW: return $this-\u0026gt;user; break; case self::USER_STR: return $this-\u0026gt;user-\u0026gt;toString(); break; case self::USER_ARRAY: return $this-\u0026gt;user-\u0026gt;toArray(); break; default: return $this-\u0026gt;user; } } } 看到这，各位看官会问了，这不是拖了裤子**嘛！明明传一个数字进来就OK了.\n这个问题问的好，因为这种优(wen)雅(yi)的方式肯定不是用于传一种参数的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /** * 用户模块 */ class UserModule { const USER_RAW = 1; const USER_STR = 2; const USER_ARRAY = 4; const USER_MSG_ID = 16; const USER_MSG_BASE = 32; const USER_MSG_ALL = 64; /** * @var User */ protected $user; public function getInfo($options = self::INFO_RAW) { $msg_type = __parse_bitwise_params($options, self::USER_MSG_ID | self::USER_MSG_BASE | self::USER_MSG_ALL); if ($msg_type == self::USER_MSG_ID) { return $this-\u0026gt;user-\u0026gt;id; } $type = __parse_bitwise_params($options, self::USER_RAW | self::USER_STR | self::USER_ARRAY); $get_user_msg = function($opt) { if ($opt == self::USER_MSG_BASE) { return array_only($this-\u0026gt;user-\u0026gt;toArray(), [\u0026#39;id\u0026#39;, user_name\u0026#39;, \u0026#39;age\u0026#39;]); } else { return $this-\u0026gt;user-\u0026gt;toArray(); } } switch($type){ case self::INFO_RAW: return $this-\u0026gt;user; break; case self::INFO_STR: return json_encode($get_user_msg($msg_type)); break; case self::INFO_ARRAY: return $get_user_msg($msg_type); break; default: return $this-\u0026gt;user; } } } 这才是为师的完全体！（不要吐槽那个匿名函数，只是想一个函数写完得了\u0026hellip;.）\n没错，这种写法就是用来传多个参数设计的，那么如果我们使用了这种方案设计代码，外部的调用将会很简单。\n1 2 3 4 5 6 7 8 9 10 11 //获取user_id $user_id = $userModule-\u0026gt;getInfo(UserModule::INFO_MSG_ID); //获取User模型 $user = $userModule-\u0026gt;getInfo(UserModule::INFO_RAW); //获取用户的信息数组 $user = $userModule-\u0026gt;getInfo(UserModule::USER_ARRAY); //获取用户的基本数据 $user_base = $userModule-\u0026gt;getInfo(UserModule::USER_ARRAY | UserModule::USER_MSG_BASE); 总结： 对于这种模块的设计，这种方案不一定是最好的，因为设计代码的方式千千万，这只是一块砖，希望能对大家的代码设计带来新的灵感。\n原创文章，转载请注明出处链接。\n","date":"2017-03-23T10:27:58Z","permalink":"https://reatang.com/p/old-post-22/","title":"php优雅的获取大量的参数——位掩码"},{"content":"帮助函数\n验证18位身份证的校验位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 身份证验证 * @param $id_card * * @return bool */ function check_id_card($id_card) { $id_card = strtoupper($id_card); //验证有效性 $pattern = \u0026#39;/^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$|^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$/\u0026#39;; $passed = preg_match($pattern, $id_card); if ($passed == 0) { return (bool) $passed; } if (strlen($id_card) == 15) { return true; } //验证校验位 $a = str_split($id_card, 1); $w = array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); $c = array(1, 0, \u0026#39;X\u0026#39;, 9, 8, 7, 6, 5, 4, 3, 2); $sum = 0; for ($i = 0; $i \u0026lt; 17; $i++) { $sum += $a[$i] * $w[$i]; } return $c[$sum % 11] == $a[17]; } ","date":"2017-03-22T18:50:04Z","permalink":"https://reatang.com/p/old-post-21/","title":"【常用函数】php 身份证有效性验证函数 check_idcard()"},{"content":"帮助函数\n分析身份证的：省、市、区、生日、性别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 身份证信息获取 * * @param string $idcard_no * * @return array */ function idcard_msg($idcard_no) { $province = substr($idcard_no, 0, 2); $city = substr($idcard_no, 2, 2); $district = substr($idcard_no, 4, 2); if (strlen($idcard_no) == 15) { $year = \u0026#39;19\u0026#39; . substr($idcard_no, 6, 2); $month = substr($idcard_no, 8, 2); $day = substr($idcard_no, 10, 2); $sex_num = substr($idcard_no, 14, 1); } else { $year = substr($idcard_no, 6, 4); $month = substr($idcard_no, 10, 2); $day = substr($idcard_no, 12, 2); $sex_num = substr($idcard_no, 16, 1); } $birthday = \u0026#34;{$year}-{$month}-{$day}\u0026#34;; $sex = $sex_num % 2 == 1 ? \u0026#39;男\u0026#39; : \u0026#39;女\u0026#39;; return compact(\u0026#39;province\u0026#39;, \u0026#39;city\u0026#39;, \u0026#39;district\u0026#39;, \u0026#39;birthday\u0026#39;, \u0026#39;sex\u0026#39;); } ","date":"2017-03-22T18:48:57Z","permalink":"https://reatang.com/p/old-post-20/","title":"【常用函数】php 身份证信息分析函数 idcard_msg()"},{"content":"帮助函数\n将php的数组解析为一个可inculde的php文件\n1 2 3 4 5 6 7 8 9 10 11 12 /** * 将数据输出到文件中,并可直接include引入 * * @param array $input * @param $file_name * * @return int */ function array_into_file(array $input, $file_name) { return file_put_contents($file_name, \u0026#34;\u0026lt;?php\\nreturn \u0026#34; . var_export($input, true) . \u0026#34;;\\n\u0026#34;); } ","date":"2017-03-22T18:46:56Z","permalink":"https://reatang.com/p/old-post-19/","title":"【常用函数】将php数组写入文件array_into_file(),可直接用inlcude读取"},{"content":"unknown variable \u0026rsquo;log_slow_queries=/var/log/mysql/mysql-slow.log'\n# mysql5.6版本以上，取消了参数log-slow-queries，更改为slow-query-log-file\n# 还需要加上 slow_query_log = on 否则，还是没用\n#log-slow-queries = /var/log/mysql/mysql-slow.log\nslow_query_log = on\nslow-query-log-file = /var/log/mysql/mysql-slow.log\nlong_query_time = 2\n","date":"2017-03-20T00:16:01Z","permalink":"https://reatang.com/p/old-post-18/","title":"mysql 5.7 unknown variable 'log_slow_queries=/var/log/mysql/mysql-slow.log'"},{"content":"每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲 区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）.\n无名管道PIPE只适用于父子进程间的通信,还有一种叫做有名管道FIFO.\nPIPE是Linux进程间通信方法之一,它是一个单向通道,先进先出,管道的尾端为写端,描述符pipe_fd[1] . 头部为读端,描述符为pipe_fd[0](注意,强制规定).\n主要函数:\n1 int pipe(int pipe_fd[2]) 调用pipe函数在内核中开辟一块缓冲区(称为管道)用于单向通信,它有一个读端一个写端,然后通过filedes参数传给用户程序两个文件描述符,filedes[0]指\n向PIPE的读端,filedes[1]指向PIPE的写端。所以在用户程序看起来就像一个打开的文件,通过read(filedes[0]);或者write(filedes[1]); 向这个文件读写数据\n其实是在读写内核缓冲区.\n创建无名管道步骤：\n父进程调用pipe(int pipe_fd[2])函数,创建管道并得到两个文件描述符,分别指向管道的头部和尾部,也就是读端和写端\n父进程调用fork()函数创建子进程,因为fork()函数,子进程拷贝父进程的数据段和代码段,所以子进程也能得到第一步创建的两个文件描述符,且指向同一个管道\n父进程关闭管道的读端,子进程关闭管道的写端\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char buf[20]; pid_t pid; int pipe_fd[2]; pipe(pipe_fd); //创建管道 if ((pid = fork()) \u0026lt; 0) //fork子进程 { perror(\u0026#34;fork error\u0026#34;); exit(-1); } else if (pid == 0) //子进程中 { close(pipe_fd[1]); //关闭写端 sleep(1); read(pipe_fd[0],buf,sizeof(buf)); printf(\u0026#34;%s\u0026#34;,buf); close(pipe_fd[0]); //关闭读端 exit(0); //正常退出 } else //父进程中 { close(pipe_fd[0]); //关闭读端 write(pipe_fd[1],\u0026#34;hello world\u0026#34;,strlen(\u0026#34;hello world\u0026#34;)); close(pipe_fd[1]); //关闭写端 waitpid(pid,NULL,0); //等待子进程结束或中断,参数1为欲等待的子进程的标识码,参数2为 //子进程结束的状态值一般为NULL,参数3为等待何种子进程,为0时表示等待进程组识别码 //与目前进程相同的任务子进程 exit(0); } } 图解：\n来自： http://blog.csdn.net/my9074/article/details/42919647\n","date":"2017-03-18T13:50:17Z","permalink":"https://reatang.com/p/old-post-17/","title":"Linux进程间通信——无名管道"},{"content":"一张图解释该如何选择开源协议\n","date":"2017-03-16T18:05:02Z","permalink":"https://reatang.com/p/old-post-16/","title":"【转】图解开源协议"},{"content":"今天有幸看到一篇 shell中交互输入自动化 的文章，对于SDTIN的理解好像是又加深了一层\n然后尝试用PHP来实现，果然是可以的，简直棒棒的。\n祭出代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;?php /** * 与shell程序使用管道进行交互 */ //定义要开启的管道 $descriptorspec = array( 0 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;r\u0026#34;), // 标准输入，子进程从此管道中读取数据 1 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;), // 标准输出，子进程向此管道中写入数据 2 =\u0026gt; array(\u0026#34;file\u0026#34;, \u0026#34;./error-output.txt\u0026#34;, \u0026#34;a\u0026#34;) // 标准错误，写入到一个文件 ); //读入要生成的文件名 if (!isset($argv[1])) {exit(\u0026#39;请输入秘钥文件名！\u0026#39;);} $key_name = $argv[1]; //参数 $params =\u0026lt;\u0026lt;\u0026lt;PARAM CN Beijing beijing Rea .Ltd technology section reatang.com admin@reatang.com PARAM; //打开进程 $process = proc_open(\u0026#34;openssl req -new -newkey rsa:2048 -nodes -keyout {$key_name}.key -out {$key_name}.csr\u0026#34;, $descriptorspec, $pipes, __DIR__); if (is_resource($process)) { //与进程进行交互 fwrite($pipes[0], $params); fclose($pipes[0]); //交互完成 echo stream_get_contents($pipes[1]); fclose($pipes[1]); $return_value = proc_close($process); echo \u0026#34;command returned $return_value\\n\u0026#34;; } 这样就自动完成了和命令的交互！OMG简直赞！还是我的基础功夫不扎实呀，之前学习给网站加证书的时候就在想如何能自动生成CSR文件，现在OK了！！\n","date":"2017-03-07T18:52:49Z","permalink":"https://reatang.com/p/old-post-15/","title":"震惊！php还能这么玩！如何与可交互的程序进行交互"},{"content":"就是一个把秒数 转换为 天:时:分:秒 格式 而已啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 把秒数转换为时间 * * @param int $sec 秒数 * @param string $format 格式化 * @param bool $zero_pad * * @return mixed|string */ function sec2date($sec, $format = \u0026#34;:D天:H小时:M分钟:S秒\u0026#34;, $zero_pad = false) { if (!is_numeric($sec)) { return false; } $days = floor($sec / 86400); $tmp = $sec - ($days * 86400); $hours = floor($tmp / 3600); $tmp2 = $tmp - ($hours * 3600); $minute = floor($tmp2 / 60); $second = $tmp2 - ($minute * 60); $fmt = array(\u0026#39;:D\u0026#39; =\u0026gt; $days,\u0026#39;:H\u0026#39; =\u0026gt; $hours,\u0026#39;:M\u0026#39; =\u0026gt; $minute,\u0026#39;:S\u0026#39; =\u0026gt; $second); if ($zero_pad === true) { $fmt = array_map(function($val){ return str_pad($val, 2, STR_PAD_LEFT); }, $fmt); } $output = str_replace(array_keys($fmt), array_values($fmt), $format); return $output; } ","date":"2017-02-28T18:18:00Z","permalink":"https://reatang.com/p/old-post-14/","title":"php把秒数转换为可读的时间函数 sec2date()"},{"content":"composer国内源有bug 会导致部分依赖包下载错误。\n比如 \u0026ldquo;jenssegers/mongodb\u0026rdquo;: \u0026ldquo;3.1.*\u0026rdquo; 组件支持 laravel ^5.1 相当于支持 大于 5.1的各个版本。可是laravel自己可不支持各个版本。导致主框架用的是5.1 可是被下载了5.4的组件，项目无法运行。\n如果出现组件下载后报bug的问题，可切换到国外源再进行安装。\n感觉国外源太慢，而且不会翻墙的，请将国内源：\n1 {\u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://packagist.phpcomposer.com\u0026#34;} 改为：\n1 {\u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://pkg.overtrue.me\u0026#34;} 并执行命令：\n1 \u0026gt; composer config --global secure-http false ","date":"2017-02-17T17:26:24Z","permalink":"https://reatang.com/p/old-post-13/","title":"composer 依赖错误会下载较高版本的组件"},{"content":"因为中国的网络原因，需要使用vargant的时候，先会把box文件用一些工具下载下来，然后进行本地安装。\n那么下载完成后，把box添加到vagrant中就是一件比较麻烦的事情了。\n从vagrant的文档中可以找到一个快速配置本地box的方法 \u0026raquo;传送门，可以自定义box的metadata来添加box。\n这里用laravel/homestead做例子。\n1、准备工作 首先我们当然要把box文件下载下来。（假设已下载，文件是 /User/my/downloads/homestead_virtualbox_1.1.0.box）\n然后创建一个文件：metadata.json\n文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;name\u0026#34;: \u0026#34;laravel/homestead\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;laravel develop environment Ubuntu 16.04 LTS 64-bit and PHP71.\u0026#34;, \u0026#34;versions\u0026#34;: [ { \u0026#34;version\u0026#34;: \u0026#34;1.1.0\u0026#34;, \u0026#34;providers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;virtualbox\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/User/my/downloads/omestead_virtualbox_1.1.0.box\u0026#34;, \u0026#34;checksum_type\u0026#34;: \u0026#34;sha1\u0026#34;, \u0026#34;checksum\u0026#34;: \u0026#34;298107a16521fd379e39a70187722fb4dc3b6880\u0026#34; #这个值可以用命令自己算一下，要不然没法通过验证 } ] } ] } 2、添加到vagrant 然后运行命令：\n1 \u0026gt;vagrant box add metadata.json 这样就可以把box添加到vagrant中了\n3、启动homestead 克隆homestead到本地：\n1 \u0026gt;git clone git@github.com:laravel/homestead.git 跳转到目录下：\n1 \u0026gt;cd homestead 启动homestead：\n1 \u0026gt;vagrant up 配置登录：\n1 2 3 alias vm=\u0026#34;ssh vagrant@127.0.0.1 -p 2222\u0026#34; #然后用vm登录 \u0026gt; vm 剩下的就看laravel/homestead的教程吧~ \u0026raquo;传送门\n","date":"2017-02-11T15:57:00Z","permalink":"https://reatang.com/p/old-post-12/","title":"从本地下载的box 安装vagrant box."},{"content":"编码后也可以正确的用json_decode进行解码\n1、使用正则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 解决json_encode的中文兼容问题（虽然看似兼容5.2不过没测试过） * * @param array|stdClass $value 被编码的数据 * * @return 编码为json字符串的数据 */ function json_encode_unescaped_unicode($value) { static $callback; if (version_compare(PHP_VERSION, \u0026#39;5.4.0\u0026#39;, \u0026#39;\u0026lt;\u0026#39;)) { if (!is_callable($callback)) { $callback = create_function(\u0026#39;$matchs\u0026#39;, \u0026#39;return iconv(\\\u0026#39;UCS-2BE\\\u0026#39;, \\\u0026#39;UTF-8\\\u0026#39;, pack(\\\u0026#39;H4\\\u0026#39;, $matchs[1]));\u0026#39; ); } $str = json_encode($value); $str = preg_replace_callback(\u0026#34;#\\\\\\u([0-9a-f]{4})#i\u0026#34;, $callback, $str); return $str; } else { return json_encode($value, JSON_UNESCAPED_UNICODE); } } 性能测试（环境：MACBOOKPRO 13 2015款）\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;?php //////////////////////////////////////////////////////////////// /// 解决 5.4以下的encode中文没有 JSON_UNESCAPED_UNICODE 选项的问题 //////////////////////////////////////////////////////////////// $num = 0; $count = 0; $time = microtime(true); function my_log() { global $count, $time, $num; if (microtime(true) - $time \u0026gt;= 1) { printf(\u0026#34;次数:%d\\n\u0026#34;, $count); $count = 0; $time = microtime(true); $num++; } } register_tick_function(\u0026#39;my_log\u0026#39;); /** * 解决json_encode的中文兼容问题（虽然看似兼容5.2不过没测试过） * * @param array|stdClass $value 被编码的数据 * * @return 编码为json字符串的数据 */ function json_encode_unescaped_unicode($value) { static $callback; if (version_compare(PHP_VERSION, \u0026#39;5.4.0\u0026#39;, \u0026#39;\u0026lt;\u0026#39;)) { if (!is_callable($callback)) { $callback = create_function(\u0026#39;$matchs\u0026#39;, \u0026#39;return iconv(\\\u0026#39;UCS-2BE\\\u0026#39;, \\\u0026#39;UTF-8\\\u0026#39;, pack(\\\u0026#39;H4\\\u0026#39;, $matchs[1]));\u0026#39; ); } $str = json_encode($value); $str = preg_replace_callback(\u0026#34;#\\\\\\u([0-9a-f]{4})#i\u0026#34;, $callback, $str); return $str; } else { return json_encode($value, JSON_UNESCAPED_UNICODE); } } $data = array( \u0026#39;qwe\u0026#39; =\u0026gt; \u0026#39;你好世界\u0026#39;, \u0026#39;asd\u0026#39; =\u0026gt; array( \u0026#39;神奇了\u0026#39;, \u0026#39;zxc\u0026#39; =\u0026gt; array( \u0026#39;s\u0026#39; =\u0026gt; \u0026#39;那么再深一点\u0026#39; ) ) ); declare(ticks = 1) { while ($num \u0026lt; 10) { json_encode_unescaped_unicode($data); $count++; } } php5.3：（每秒encode次数）\n次数:39405\n次数:39829\n次数:40229\n次数:40300\n次数:40425\n次数:41298\n次数:38226\n次数:40405\n次数:40758\n次数:39853\nphp5.6：(每秒encode次数)\n次数:380351\n次数:376383\n次数:384623\n次数:385797\n次数:381795\n次数:374920\n次数:366855\n次数:380634\n次数:373909\n次数:379061\n性能上的差异肯定是有的毕竟又用正则又用iconv的。\n从测试上看，9倍左右的差距应该还包含php5.6本身就比5.3快的原因。\n不过这个差距是有点大，那么还是赶紧升级php5.6吧，现在的大趋势都是7.1了，还在用老款干啥呀，各种新特性高性能在等着各位phper！（跑题了）\n2、先用urlencode编码中文，在json_encode之后再用urldecode转换回来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function json_encode_unescaped_unicode($value, $is_deep = false) { if (version_compare(PHP_VERSION, \u0026#39;5.4.0\u0026#39;, \u0026#39;\u0026lt;\u0026#39;)) { foreach ($value as $k =\u0026gt; \u0026amp;$v) { if (is_string($v)) { $v = urlencode($v); } else if (is_array($v)) { $v = json_encode_unescaped_unicode($v, true); } } return $is_deep ? $value : urldecode(json_encode($value)); } else { return json_encode($value, JSON_UNESCAPED_UNICODE); } } 同样的测试，这个性能没高多少，而且还带着个递归\nphp5.3：\n次数:72744\n次数:72718\n次数:74101\n次数:75071\n次数:75672\n次数:73354\n次数:75474\n次数:73025\n次数:74453\n次数:75715\n原创文章转载请注明出处哟！\n","date":"2017-02-06T14:23:17Z","permalink":"https://reatang.com/p/old-post-11/","title":"解决json_encode中文会编码为unicode，兼容php5.4之前的版本"},{"content":"来自： https://www.qcloud.com/community/article/164816001481011945\n最近研发的项目对DB依赖比较重，梳理了这段时间使用MySQL遇到的8个比较具有代表性的问题，答案也比较偏自己的开发实践，没有DBA专业和深入，有出入的请使劲拍砖！\u0026hellip;\nMySQL读写性能是多少，有哪些性能相关的配置参数？\nMySQL负载高时，如何找到是由哪些SQL引起的？\n如何针对具体的SQL做优化？\nSQL层面已难以优化，请求量继续增大时的应对策略？\nMySQL如何做主从数据同步？\n如何防止DB误操作和做好容灾？\n该选择MySQL哪种存储引擎，Innodb具有什么特性？\nMySQL内部结构有哪些层次？\n1.MySQL读写性能是多少，有哪些性能相关的重要参数？ 这里做了几个简单压测实验\n机器：8核CPU，8G内存\n表结构(尽量模拟业务)：12个字段(1个bigint(20)为自增primary key，5个int(11)，5个varchar(512)，1个timestamp)，InnoDB存储引擎。\n实验1(写)：insert =\u0026gt; 6000/s\n前提：连接数100，每次insert单条记录\n分析：CPU跑了50%，这时磁盘为顺序写，故性能较高\n实验2(写)：update(where条件命中索引) =\u0026gt; 200/s\n前提：连接数100，10w条记录，每次update单条记录的4个字段(2个int(11)，2个varchar(512))\n分析：CPU跑2%，瓶颈明显在IO的随机写\n实验3(读)：select(where条件命中索引) =\u0026gt; 5000/s\n前提：连接数100，10w条记录，每次select单条记录的4个字段(2个int(11)，2个varchar(512))\n分析：CPU跑6%，瓶颈在IO，和db的cache大小相关\n实验4(读)：select(where条件没命中索引) =\u0026gt; 60/s\n前提：连接数100，10w条记录，每次select单条记录的4个字段(2个int(11)，2个varchar(512))\n分析：CPU跑到80%，每次select都需遍历所有记录，看来索引的效果非常明显！\n几个重要的配置参数，可根据实际的机器和业务特点调整\nmax_connecttions：最大连接数\ntable_cache：缓存打开表的数量\nkey_buffer_size：索引缓存大小\nquery_cache_size：查询缓存大小\nsort_buffer_size：排序缓存大小(会将排序完的数据缓存起来)\nread_buffer_size：顺序读缓存大小\nread_rnd_buffer_size：某种特定顺序读缓存大小(如order by子句的查询)\nPS：查看配置方法： show variables like '%max_connecttions%';\n2.MySQL负载高时，如何找到是由哪些SQL引起的？ 方法：慢查询日志分析(MySQLdumpslow)\n慢查询日志例子，可看到每个慢查询SQL的耗时：\n1 # User@Host: edu_online[edu_online] @ [10.139.10.167]# Query_time: 1.958000 Lock_time: 0.000021 Rows_sent: 254786 Rows_examined: 254786SET timestamp=1410883292;select * from t_online_group_records; 日志显示该查询用了1.958秒，返回254786行记录，一共遍历了254786行记录。及具体的时间戳和SQL语句。\n使用MySQLdumpslow进行慢查询日志分析\nMySQLdumpslow -s t -t 5 slow_log_20140819.txt\n输出查询耗时最多的Top5条SQL语句\n-s：排序方法，t表示按时间 (此外，c为按次数，r为按返回记录数等)\n-t：去Top多少条，-t 5表示取前5条\n执行完分析结果如下：\n1 2 3 4 5 6 Count: 1076100 Time=0.09s (99065s) Lock=0.00s (76s) Rows=408.9 (440058825), edu_online[edu_online]@28hosts select * from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) \u0026gt; NCount: 1076099 Time=0.05s (52340s) Lock=0.00s (91s) Rows=62.6 (67324907), edu_online[edu_online]@28hosts select * from t_online_course where UNIX_TIMESTAMP(c_updatetime) \u0026gt; NCount: 63889 Time=0.78s (49607s) Lock=0.00s (3s) Rows=0.0 (18), edu_online[edu_online]@[10x.213.1xx.1xx] select f_uin from t_online_student_contact where f_modify_time \u0026gt; NCount: 1076097 Time=0.02s (16903s) Lock=0.00s (72s) Rows=52.2 (56187090), edu_online[edu_online]@28hosts select * from t_online_video_info where UNIX_TIMESTAMP(v_update_time) \u0026gt; NCount: 330046 Time=0.02s (6822s) Lock=0.00s (45s) Rows=0.0 (2302), edu_online[edu_online]@4hosts select uin,cid,is_canceled,unix_timestamp(end_time) as endtime,unix_timestamp(update_time) as updatetime from t_kick_log where unix_timestamp(update_time) \u0026gt; N 以第1条为例，表示这类SQL(N可以取很多值，这里MySQLdumpslow会归并起来)在8月19号的慢查询日志内出现了1076100次，总耗时99065秒，总返回440058825行记录，有28个客户端IP用到。\n通过慢查询日志分析，就可以找到最耗时的SQL，然后进行具体的SQL分析了\n慢查询相关的配置参数\nlog_slow_queries：是否打开慢查询日志，得先确保=ON后面才有得分析\nlong_query_time：查询时间大于多少秒的SQL被当做是慢查询，一般设为1S\nlog_queries_not_using_indexes：是否将没有使用索引的记录写入慢查询日志\nslow_query_log_file：慢查询日志存放路径\n3.如何针对具体的SQL做优化？ 使用Explain分析SQL语句执行计划\n1 2 3 4 5 6 7 MySQL\u0026gt; explain select * from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) \u0026gt; 123456789; +----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | t_online_group_records | ALL | NULL | NULL | NULL | NULL | 47 | Using where | +----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+ 1 row in set (0.00 sec) 如上面例子所示，重点关注下type，rows和Extra：\ntype：使用类别，有无使用到索引。结果值从好到坏：\u0026hellip; \u0026gt; range(使用到索引) \u0026gt; index \u0026gt; ALL(全表扫描)，一般查询应达到range级别\nrows：SQL执行检查的记录数\nExtra：SQL执行的附加信息，如\u0026quot;Using index\u0026quot;表示查询只用到索引列，不需要去读表等\n使用Profiles分析SQL语句执行时间和消耗资源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 MySQL\u0026gt; set profiling=1; (启动profiles，默认是没开启的) MySQL\u0026gt; select count(1) from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) \u0026gt; 123456789; (执行要分析的SQL语句) MySQL\u0026gt; show profiles; +----------+------------+----------------------------------------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+----------------------------------------------------------------------------------------------+ | 1 | 0.00043250 | select count(1) from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) \u0026gt; 123456789 | +----------+------------+----------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 、 MySQL\u0026gt; show profile cpu,block io for query 1; (可看出SQL在各个环节的耗时和资源消耗) +----------------------+----------+----------+------------+--------------+---------------+ | Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | +----------------------+----------+----------+------------+--------------+---------------+ ... | statistics | 0.000020 | 0.000000 | 0.000000 | 0 | 0 | | optimizing | 0.000016 | 0.000000 | 0.000000 | 0 | 0 | | executing | 0.000011 | 0.000000 | 0.000000 | 0 | 0 | | preparing | 0.000017 | 0.000000 | 0.000000 | 0 | 0 | | Sending data | 0.000076 | 0.000000 | 0.000000 | 0 | 0 | ... SQL优化的技巧 (只提一些业务常遇到的问题)\n最关键：索引，避免全表扫描。\n对接触的项目进行慢查询分析，发现TOP10的基本都是忘了加索引或者索引使用不当，如索引字段上加函数导致索引失效等(如 where UNIX_TIMESTAMP(gre_updatetime)\u0026gt;123456789)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 +----------+------------+---------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------+ | 1 | 0.00024700 | select * from mytable where id=100 | | 2 | 0.27912900 | select * from mytable where id+1=101 | +----------+------------+---------------------------------------+ 另外很多同学在拉取全表数据时，喜欢用select xx from xx limit 5000,1000这种形式批量拉取，其实这个SQL每次都是全表扫描，建议添加1个自增id做索引， 将SQL改为select xx from xx where id\u0026gt;5000 and id\u0026lt;6000; +----------+------------+-----------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+-----------------------------------------------------+ | 1 | 0.00415400 | select * from mytable where id\u0026gt;=90000 and id\u0026lt;=91000 | | 2 | 0.10078100 | select * from mytable limit 90000,1000 | +----------+------------+-----------------------------------------------------+ 合理用好索引，应该可解决大部分SQL问题。当然索引也非越多越好，过多的索引会影响写操作性能 只select出需要的字段，避免select\n1 2 3 4 5 6 +----------+------------+-----------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+-----------------------------------------------------+ | 1 | 0.02948800 | select count(1) from ( select id from mytable ) a | | 2 | 1.34369100 | select count(1) from ( select * from mytable ) a | +----------+------------+-----------------------------------------------------+ 尽量早做过滤，使Join或者Union等后续操作的数据量尽量小\n把能在逻辑层算的提到逻辑层来处理，如一些数据排序、时间函数计算等\n\u0026hellip;\u0026hellip;.\nPS：关于SQL优化，已经有足够多文章了，所以就不讲太全面了，只重点说自己1个感受：索引！基本都是因为索引！\n4.SQL层面已难以优化，请求量继续增大时的应对策略？ 下面是我能想到的几个方法，每个方法又都是一篇大文章了，这里就不展开\n分库分表\n使用集群(master-slave)，读写分离\n增加业务的cache层\n使用连接池\n5.MySQL如何做主从数据同步？ 复制机制（Replication）\nmaster通过复制机制，将master的写操作通过binlog传到slave生成中继日志(relaylog)，slave再将中继日志redo，使得主库和从库的数据保持同步\n复制相关的3个MySQL线程\nslave上的I/O线程：向master请求数据\nmaster上的Binlog Dump线程：读取binlog事件并把数据发送给slave的I/O线程\nslave上的SQL线程：读取中继日志并执行，更新数据库\n属于slave主动请求拉取的模式\n实际使用可能遇到的问题\n数据非强一致：CDB默认为异步复制，master和slave的数据会有一定延迟(称为主从同步距离，一般 \u0026lt; 1s)\n主从同步距离变大：可能是DB写入压力大，也可能是slave机器负载高，网络波动等原因，具体问题具体分析\n相关监控命令\nshow processlist：查看MySQL进程信息，包括3个同步线程的当前状态\nshow master status ：查看master配置及当前复制信息\nshow slave status：查看slave配置及当前复制信息\n6.如何防止DB误操作和做好容灾？ 业务侧应做到的几点：\n重要DB数据的手工修改操作，操作前需做到2点：1 先在测试环境操作 2 备份数据\n根据业务重要性做定时备份，考虑系统可承受的恢复时间\n进行容灾演练，感觉很必要\nMySQL备份和恢复操作\n1.备份：使用MySQLdump导出数据\n1 MySQLdump -u 用户名 -p 数据库名 [表名] \u0026gt; 导出的文件名MySQLdump -uxxx -p xxx mytable \u0026gt; mytable.20140921.bak.sql 2.恢复：导入备份数据\nMySQL -uxxx -p xxxx \u0026lt; mytable.20140921.bak.sql\n3.恢复：导入备份数据之后发送的写操作。先使用MySQLbinlog导出这部分写操作SQL(基于时间点或位置)\n如导出2014-09-21 09:59:59之后的binlog：\n1 MySQLbinlog --database=\u0026#34;test\u0026#34; --start-date=\u0026#34;2014-09-21 09:59:59\u0026#34; /var/lib/MySQL/mybinlog.000001 \u0026gt; binlog.data.sql 如导出起始id为123456之后的binlog：\n1 MySQLbinlog --database=\u0026#34;test\u0026#34; --start-position=\u0026#34;123456\u0026#34; /var/lib/MySQL/mybinlog.000001 \u0026gt; binlog.data.sql 最后把要恢复的binlog导入db\nMySQL -uxxxx -p xxxx \u0026lt; binlog.data.sql\n7.该选择MySQL哪种存储引擎，Innodb具有什么特性？ 存储引擎简介\n插件式存储引擎是MySQL的重要特性，MySQL支持多种存储引擎以满足用户的多种应用场景\n存储引擎解决的问题：如何组织MySQL数据在介质中高效地读取，需考虑存储机制、索引设计、并发读写的锁机制等\nMySQL5.0支持的存储引擎有MyISAM、InnoDB、Memory、Merge等\n**MyISAM和InnoDB的区别(只说重点了)\nInnoDB\nMySQL5.5之后及CDB的默认引擎。\n支持行锁：并发性能好\n支持事务：故InnoDB称为事务性存储引擎，支持ACID，提供了具有提交、回滚和崩溃恢复能力的事务安全\n支持外键：当前唯一支持外键的引擎\nMyISAM\nMySQL5.5之前默认引擎\n支持表锁：插入+查询速度快，更新+删除速度慢\n不支持事务\n使用show engines可查看当前MySQL支持的存储引擎详情\n8.MySQL内部结构有哪些层次？ 非专业DBA，这里只简单贴个结构图说明下。MySQL是开源系统，其设计思路和源代码都出自大牛之手，有空可以学习下。\n","date":"2017-01-22T17:28:36Z","permalink":"https://reatang.com/p/old-post-10/","title":"转载:MySQL开发实践8问，你能hold住几个？"},{"content":"\n2016年度最受欢迎中国开源软件评选 \u0026raquo;原文\n4092 票 JFinal\n3956 票 ECharts\n3353 票 Layui\n2707 票 Druid\n2548 票 Vue.js\n2389 票 fastjson\n2137 票 Dubbo\n1764 票 ThinkPHP\n1467 票 JEECG\n1454 票 zTree\n1426 票 MyCAT\n1144 票 禅道\n1083 票 Apache RocketMQ\n975 票 JFinal Weixin\n853 票 JeeSite\n840 票 WeUI\n813 票 Sharding-JDBC\n808 票 Deepin\n797 票 JeeWx 捷微\n583 票 Nutz\n","date":"2017-01-22T16:31:00Z","permalink":"https://reatang.com/p/old-post-9/","title":"2016年度最受欢迎中国开源软件评选"},{"content":"fastdfs-5.0.9.tar.gz\nfastdfs-gninx-module-1.19.tar.gz\nlibfastcommon-1.33.tar.gz\n链接: https://pan.baidu.com/s/1gfytnxD 密码: xf52\n稍后将测试安装\n","date":"2017-01-17T15:37:15Z","permalink":"https://reatang.com/p/old-post-8/","title":"fastDFS 5.0.9 本体,lib库,nginx模块"},{"content":"占位\n","date":"2017-01-13T17:48:37Z","permalink":"https://reatang.com/p/old-post-7/","title":"得空开一篇 SOLID OOP设计原则"},{"content":"//请求内容长度\nCONTENT_LENGTH:\u0026ldquo;7\u0026rdquo;\n//请求内容类型\nCONTENT_TYPE:\u0026ldquo;application/x-www-form-urlencoded;charset=UTF-8\u0026rdquo;\n//根目录\nDOCUMENT_ROOT:\u0026quot;/home/vagrant/Code/web\u0026quot;\n//脚本名称\nDOCUMENT_URI:\u0026quot;/fetch/data.php\u0026quot;\n//cgi规则\nFCGI_ROLE:\u0026ldquo;RESPONDER\u0026rdquo;\n//接口版本\nGATEWAY_INTERFACE:\u0026ldquo;CGI/1.1\u0026rdquo;\n//启动用户家目录\nHOME:\u0026quot;/home/vagrant\u0026quot;\nUSER:\u0026ldquo;vagrant\u0026rdquo;\n//HTTP头信息\nHTTP_ACCEPT:\u0026quot;*/*\u0026quot;\nHTTP_ACCEPT_ENCODING:\u0026ldquo;gzip, deflate\u0026rdquo;\nHTTP_ACCEPT_LANGUAGE:\u0026ldquo;zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4\u0026rdquo;\nHTTP_CACHE_CONTROL:\u0026ldquo;no-cache\u0026rdquo;\nHTTP_CONNECTION:\u0026ldquo;keep-alive\u0026rdquo;\nHTTP_CONTENT_LENGTH:\u0026ldquo;7\u0026rdquo;\nHTTP_CONTENT_TYPE:\u0026ldquo;application/x-www-form-urlencoded;charset=UTF-8\u0026rdquo;\nHTTP_HOST:\u0026ldquo;www.xxx.com\u0026rdquo;\nHTTP_ORIGIN:\u0026ldquo;http://www.xxx.com\u0026rdquo;\nHTTP_PRAGMA:\u0026ldquo;no-cache\u0026rdquo;\nHTTP_REFERER:\u0026quot; http://web.l.org/fetch/\u0026quot;\nHTTP_USER_AGENT:\u0026ldquo;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\u0026rdquo;\n//PHP发现的，自己运行的脚本文件\nPHP_SELF:\u0026quot;/fetch/data.php\u0026quot;\n//请求类型\nREQUEST_METHOD:\u0026ldquo;POST\u0026rdquo;\n//url中 ? 后面的\nQUERY_STRING:\u0026quot;\u0026quot;\n//重写状态（nginx重写过）\nREDIRECT_STATUS:\u0026ldquo;200\u0026rdquo;\n//远程IP\nREMOTE_ADDR:\u0026ldquo;192.168.10.1\u0026rdquo;\n//远程端口\nREMOTE_PORT:\u0026ldquo;57455\u0026rdquo;\n//服务器IP\nSERVER_ADDR:\u0026ldquo;192.168.10.10\u0026rdquo;\n//服务器端口\nSERVER_PORT:\u0026ldquo;80\u0026rdquo;\nSERVER_NAME:\u0026quot; http://www.xxx.com\u0026quot;\nSERVER_PROTOCOL:\u0026ldquo;HTTP/1.1\u0026rdquo;\nSERVER_SOFTWARE:\u0026ldquo;nginx/1.9.14\u0026rdquo;\n//请求时间\nREQUEST_TIME:1482224205\n//请求时间 毫秒级\nREQUEST_TIME_FLOAT:1482224205.7445\n//URI\nREQUEST_URI:\u0026quot;/fetch/data.php\u0026quot;\n//脚本全路径\nSCRIPT_FILENAME:\u0026quot;/home/vagrant/Code/web/fetch/data.php\u0026quot;\nSCRIPT_NAME:\u0026quot;/fetch/data.php\u0026quot;\n","date":"2017-01-13T15:40:15Z","permalink":"https://reatang.com/p/old-post-6/","title":"php 超全局变量$_SERVER 内容"},{"content":"js部分\njs使用的是crypto-js进行aes加密\ngithub地址：https://github.com/brix/crypto-js\n加密\n1 2 3 4 5 var md5SecterKey = \u0026#39;a1d3eaf653ab8d9c2c1d809f13ab5f05\u0026#39;; var key = crypto.enc.Utf8.parse(md5SecterKey); var iv = crypto.enc.Utf8.parse(md5SecterKey); var ciphertext = crypto.AES.encrypt(data, key, { iv: iv,mode:crypto.mode.CBC,padding:crypto.pad.ZeroPadding}); console.log(ciphertext.toString()); 解密\n1 2 3 4 5 6 7 8 var key = crypto.enc.Utf8.parse(md5SecterKey); var iv = crypto.enc.Utf8.parse(md5SecterKey); var ciphertext = localStorage.getItem(name); if(ciphertext){ var bytes = crypto.AES.decrypt(ciphertext.toString(), key, { iv: iv,mode:crypto.mode.CBC,padding:crypto.pad.ZeroPadding}); var plaintext = bytes.toString(crypto.enc.Utf8); return plaintext; } php部分\nphp使用自带的aes解密\n加密\n1 2 3 4 5 $pk = \u0026#34;a1d3eaf653ab8d9c2c1d809f13ab5f05\u0026#34;; $iv = substr($pk, 0, 16); $t = \u0026#39;reatang\u0026#39;; $encrypted = ( mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $pk, $t, MCRYPT_MODE_CBC,$iv) ); $base64Str = base64_encode($encrypted).\u0026#39;\u0026lt;br\u0026gt;\u0026#39;; 解密\n1 2 3 4 5 $str_encrypt = base64_decode($base64Str); $pk = \u0026#34;a1d3eaf653ab8d9c2c1d809f13ab5f05\u0026#34;; $iv = substr($pk, 0, 16); echo mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $pk, base64_decode($str_encrypt), MCRYPT_MODE_CBC, $iv); exit; ","date":"2017-01-13T10:38:15Z","permalink":"https://reatang.com/p/old-post-4/","title":"js_ase加密php_ase解密"}]